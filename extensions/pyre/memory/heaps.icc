// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2025 all rights reserved

// code guard
#pragma once

// declarations
#include "heaps.h"
// common properties
#include "properties.h"
// accessors
#include "accessors.h"
// mutators
#include "mutators.h"
// buffer protocol
#include "buffer_protocol.h"


// the type registrar
template <class... heapT>
auto
pyre::py::memory::heaps::expand(py::module & memory, pyre::typelists::types_t<heapT...> &&) -> void
{
    // register the heap types
    (heap<heapT>(memory), ...);
    // all done
    return;
}

// the heap class record builder
template <class heapT>
auto
pyre::py::memory::heaps::heap(py::module & memory) -> void
{
    // alias the heap type
    using heap_t = heapT;

    // build the name of the class
    auto clsName = heap_t::name();
    // the docstring
    auto clsDocstring = docstring<heap_t>();

    // assemble the class record
    auto heap = pyheap_t<heap_t>(
        // scope
        memory,
        // name
        clsName.data(),
        // add support for the buffer protocol
        py::buffer_protocol(),
        // docstring
        clsDocstring.data());

    // constructors
    constructors(heap);
    // properties
    properties(heap);
    // accessors
    accessors(heap);
    // mutable heaps
    if constexpr (!heap_t::readonly()) {
        // get mutators
        mutators(heap);
    }
    // buffer protocol support
    bufferProtocol(heap);

    // all done
    return;
}

// constructors
template <class heapT>
auto
pyre::py::memory::heaps::constructors(pyheap_t<heapT> & cls) -> void
{
    // alias the heap
    using heap_t = heapT;

    // build with a given number of cells
    cls.def(
        // the implementation
        py::init<typename heap_t::cell_count_type>(),
        // the signature
        "cells"_a,
        // the docstring
        "allocate a buffer with the given number of {cells} on the heap");

    // all done
    return;
}


// the docstring builder
template <class heapT>
auto
pyre::py::memory::heaps::docstring() -> string_t
{
    // alias the heap
    using heap_t = heapT;
    // build the docstring
    auto docstring =
        // access rights
        string_t(heap_t::readonly() ? "const" : "mutable")
        // flavor
        + " buffer of "
        // cell type
        + heap_t::cellDecl()
        // more flavor
        + " on the heap";
    // all done
    return docstring;
}


// end of file
