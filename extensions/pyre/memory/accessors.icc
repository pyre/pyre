// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2025 all rights reserved

// code guard
#pragma once


// declarations
#include "accessors.h"


// decorator that adds interface common to all storage strategies
template <class T>
auto
pyre::py::memory::accessors(pymem_t<T> & cls) -> void
{
    // alias the storage strategy
    using mem_t = T;
    // and views derived from it
    using view_t = pyre::memory::View<typename mem_t::value_type, mem_t::readonly()>;

    // metamethods
    cls.def(
        // the name
        "__len__",
        // the implementation
        &mem_t::cells,
        // the docstring
        "the number of data cells");

    cls.def(
        // the name
        "__iter__",
        // the implementation
        [](const mem_t & self) {
            // make an iterator and return it
            return py::make_iterator(self.begin(), self.end());
        },
        // keep the vector around while its iterator is in use
        py::keep_alive<0, 1>());


    cls.def(
        // the name
        "__getitem__",
        // the implementation
        // &mem_t::at,
        [](const mem_t & self, int idx) -> typename mem_t::value_type {
            // get the value
            auto value = self.at(idx);
            // and return it
            return value;
        },
        // the docstring
        "get the value of the cell at a given index");


    cls.def(
        // the name
        "__getitem__",
        // the implementation
        [](const mem_t & self, py::slice slice) -> view_t {
            // storage for the slice info
            std::size_t start = 0, stop = 0, step = 0, span = 0;
            // unpack
            auto status = slice.compute(self.cells(), &start, &stop, &step, &span);
            // if something went wrong
            if (!status) {
                // bail; pybind11 has already registered the correct exception
                throw py::error_already_set();
            }
            // make a channel
            auto channel = pyre::journal::info_t("foo");
            channel << start << " " << stop << " " << step << " " << span << pyre::journal::endl;
            // get the pointer to the data
            auto data = self.data();
            // build a view and return it
            return view_t(data + start, span, step);
        },
        // the docstring
        "get a slice from the buffer");


    // all done
    return;
}


// end of file
