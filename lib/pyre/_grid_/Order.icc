// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2025 all rights reserved

// code guard
#pragma once


// support
#include "Order.h"


// default constructor: c-style: {R-1, ..., 1, 0}
template <std::size_t Rank>
constexpr pyre::grid::Order<Rank>::Order() noexcept :
    // initialize the permutation
    _permutation { _make_row_major(std::make_index_sequence<Rank> {}) }
{}

// from a backing array
template <std::size_t Rank>
constexpr pyre::grid::Order<Rank>::Order(storage_type p) noexcept :
    // initialize the permutation
    _permutation { std::move(p) }
{}

// the variadic constructor
template <std::size_t Rank>
template <std::unsigned_integral... Ts>
    requires(sizeof...(Ts) == Rank)
constexpr pyre::grid::Order<Rank>::Order(Ts... xs) noexcept :
    // initialize the permutation
    _permutation { static_cast<value_type>(xs)... }
{}

// initializer_list (debug length check)
template <std::size_t Rank>
constexpr pyre::grid::Order<Rank>::Order(std::initializer_list<value_type> ilist) noexcept
{
#if defined(DEBUG)
    assert(
        ilist.size() == Rank
        && "pyre::grid::Order: initializer_list length must equal the order rank");
#endif
    // make a counter
    size_type axis = 0;
    // go through the entries of the initializer list
    for (auto value : ilist) {
        // as long as there no overflow
        if (axis < Rank)
            // transfer the value to the next index
            _permutation[axis++] = value;
    }
    // all done
    return;
}


// accessors
template <std::size_t Rank>
consteval auto
pyre::grid::Order<Rank>::rank() noexcept -> size_type
{
    // easy enough
    return Rank;
}

// element access
template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::operator[](size_type axis) noexcept -> reference
{
    // easy enough
    return _permutation[axis];
}

template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::operator[](size_type axis) const noexcept -> const_reference
{
    // easy enough
    return _permutation[axis];
}


// access to the underlying storage
template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::data() noexcept -> pointer
{
    // easy enough
    return _permutation.data();
}

template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::data() const noexcept -> const_pointer
{
    // easy enough
    return _permutation.data();
}


// utilities
// convenience factories
template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::c() noexcept -> self_type
{
    // use the factory to build and initialize an {Order}
    return self_type { _make_row_major(std::make_index_sequence<Rank> {}) };
};

template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::fortran() noexcept -> self_type
{
    // use the factory to build and initialize an {Order}
    return self_type { _make_column_major(std::make_index_sequence<Rank> {}) };
};

template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::rowMajor() noexcept -> self_type
{
    // use the factory to build and initialize an {Order}
    return self_type { _make_row_major(std::make_index_sequence<Rank> {}) };
};

template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::columnMajor() noexcept -> self_type
{
    // use the factory to build and initialize an {Order}
    return self_type { _make_column_major(std::make_index_sequence<Rank> {}) };
};

// check whether i am a permutation in S_{Rank}
template <std::size_t Rank>
[[nodiscard]] constexpr auto
pyre::grid::Order<Rank>::isPermutation() const noexcept -> bool
{
    // trivial ranks
    if constexpr (Rank == 0) {
        // pass
        return true;
    }
    // set aside some storage for marking values we've seen
    std::array<bool, Rank> seen {};
    // go through the first {Rank} integers
    for (size_type i = 0; i < Rank; ++i) {
        // look up my corresponding value
        auto value = _permutation[i];
        // if it's either out of range or we've bumped into it before
        if (value >= Rank || seen[value]) {
            // this is not a valid permutation
            return false;
        }
        // mark
        seen[value] = true;
    }
    // if we get this far, all is good
    return true;
}


// iteration support
template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::begin() noexcept -> iterator
{
    // easy enough
    return _permutation.begin();
}

template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::end() noexcept -> iterator
{
    // easy enough
    return _permutation.end();
}

template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::begin() const noexcept -> const_iterator
{
    // easy enough
    return _permutation.begin();
}

template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::end() const noexcept -> const_iterator
{
    // easy enough
    return _permutation.end();
}

template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::cbegin() const noexcept -> const_iterator
{
    // easy enough
    return _permutation.cbegin();
}

template <std::size_t Rank>
constexpr auto
pyre::grid::Order<Rank>::cend() const noexcept -> const_iterator
{
    // easy enough
    return _permutation.cend();
}


// compile time storage factories
template <std::size_t Rank>
template <std::size_t... Is>
consteval auto
pyre::grid::Order<Rank>::_make_row_major(std::index_sequence<Is...>) noexcept -> storage_type
{
    // reverse the index sequence and use it to populate a {storage_type}
    return storage_type { (Rank - 1 - Is)... };
}

template <std::size_t Rank>
template <std::size_t... Is>
consteval auto
pyre::grid::Order<Rank>::_make_column_major(std::index_sequence<Is...>) noexcept -> storage_type
{
    // use the index sequence to populate a {storage_type}
    return storage_type { Is... };
}


// end of file
