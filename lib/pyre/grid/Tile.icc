// -*- C++ -*-
// -*- coding: utf-8 -*-
//
// michael a.g. aïvázis
// orthologue
// (c) 1998-2016 all rights reserved
//

// code guard
#if !defined(pyre_grid_Tile_icc)
#error This header file contains implementation details of class pyre::grid::Tile
#endif


// meta-methods
template <typename indexT, typename layoutT>
pyre::grid::Tile<indexT, layoutT>::
Tile(index_type shape, layout_type layout) :
    _shape{shape},
    _layout{layout}
{}


// interface
// accessors
template <typename indexT, typename layoutT>
const auto &
pyre::grid::Tile<indexT, layoutT>::
shape() const {
    // easy enough...
    return _shape;
}

template <typename indexT, typename layoutT>
const auto &
pyre::grid::Tile<indexT, layoutT>::
layout() const {
    // easy enough...
    return _layout;
}

// compute the size of the tile
template <typename indexT, typename layoutT>
auto
pyre::grid::Tile<indexT, layoutT>::
size() const {
    // initialize
    size_type cells = 1;
    // go through my shape
    for (auto size : _shape) {
        // scale up my size by the extent of this axis
        cells *= size;
    }
    // all done
    return cells;
}

// cell offset for a given index
template <typename indexT, typename layoutT>
auto
pyre::grid::Tile<indexT, layoutT>::
offset(const index_type & index) const {
    // initialize the offset
    size_type offset = 0;
    // and the running product
    size_type product = 1;
    // loop over the packing order
    for (auto axis : _layout) {
        // update the offset
        offset += index[axis] * product;
        // update the product
        product *= _shape[axis];
    }
    // all done
    return offset;
}


// index for a given cell offset
template <typename indexT, typename layoutT>
auto
pyre::grid::Tile<indexT, layoutT>::
index(size_type offset) const {
    // storage for the answer
    index_type index;
    // initialize the product of all the dimension extents
    auto product = size();

    // loop in reverse packing order
    for (int dim = index.size()-1; dim >=0; --dim) {
        // pull the current shape limit out of the product
        product /= _shape[_layout[dim]];
        // compute the index
        index[_layout[dim]] = offset / product;
        // adjust the offset
        offset %= product;
    }

    // build an index and return it
    return index;
}


// the syntactic sugar
template <typename indexT, typename layoutT>
auto
pyre::grid::Tile<indexT, layoutT>::
operator[](const index_type & index) const {
    // delegate
    return offset(index);
}

template <typename indexT, typename layoutT>
auto
pyre::grid::Tile<indexT, layoutT>::
operator[](size_type offset) const {
    // delegate
    return index(offset);
}


// iteration support
template <typename indexT, typename layoutT>
auto
pyre::grid::Tile<indexT, layoutT>::
begin() const {
    // delegate
    return iterator_type {{}, _shape, _layout};
}

template <typename indexT, typename layoutT>
auto
pyre::grid::Tile<indexT, layoutT>::
end() const {
    // delegate
    return iterator_type {_shape, _shape, _layout};
}

// slicing
template <typename indexT, typename layoutT>
auto
pyre::grid::Tile<indexT, layoutT>::
slice(const layout_type & layout) const {
    // make a slice over the whole tile but with the given layout
    return slice_type(*this, {}, _shape, layout);
}


template <typename indexT, typename layoutT>
auto
pyre::grid::Tile<indexT, layoutT>::
slice(const index_type & begin, const index_type & end) const {
    // make a slice over the whole tile but with the given layout
    return slice_type(*this, begin, end, _layout);
}


template <typename indexT, typename layoutT>
auto
pyre::grid::Tile<indexT, layoutT>::
slice(const index_type & begin, const index_type & end, const layout_type & layout) const {
    // make a slice over the whole tile but with the given layout
    return slice_type(*this, begin, end, layout);
}


// end of file
