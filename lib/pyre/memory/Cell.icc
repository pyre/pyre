// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2025 all rights reserved


// code guard
#pragma once


// the declarations
#include "Cell.h"


// access privileges
template <typename T, bool isConst>
constexpr auto
pyre::memory::Cell<T, isConst>::readonly() -> bool
{
    // easy
    return isConst;
}


template <typename T, bool isConst>
constexpr auto
pyre::memory::Cell<T, isConst>::writable() -> bool
{
    // easy
    return !readonly();
}


// compute the footprint of the given number of cells
template <typename T, bool isConst>
constexpr auto
pyre::memory::Cell<T, isConst>::bits(cell_count_type n) -> size_type
{
    // easy
    return 8 * bytes(n);
}

template <typename T, bool isConst>
constexpr auto
pyre::memory::Cell<T, isConst>::bytes(cell_count_type n) -> size_type
{
    // easy
    return n * sizeof(T);
}

// simulation of my declaration
template <typename T, bool isConst>
auto
pyre::memory::Cell<T, isConst>::declSelf() -> string_type
{
    // assemble and return
    return
        // namespace
        string_type("pyre::memory::cell_t<") +
        // the value type
        declValue() +
        // the permissions
        ", " + (isConst ? "true" : "false") +
        // done
        ">";
}

// simulation of the c++ declaration of the template parameter
template <typename T, bool isConst>
auto
pyre::memory::Cell<T, isConst>::declValue() -> string_type
{
    // resolve the name and return it
    return CellName<value_type>::decl();
}

// human readable form of my class name
template <typename T, bool isConst>
auto
pyre::memory::Cell<T, isConst>::className() -> string_type
{
    // resolve the name and return it
    return CellName<value_type>::name() + (isConst ? "Const" : "");
}


// the datatype name specializations
template <>
struct pyre::memory::CellName<char> {
    // the name
    inline static auto name() -> string_t { return "Char"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "char"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::int8_t> {
    // the name
    inline static auto name() -> string_t { return "Int8"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::int8_t"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::int16_t> {
    // the name
    inline static auto name() -> string_t { return "Int16"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::int16_t"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::int32_t> {
    // the name
    inline static auto name() -> string_t { return "Int32"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::int32_t"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::int64_t> {
    // the name
    inline static auto name() -> string_t { return "Int64"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::int64_t"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::uint8_t> {
    // the name
    inline static auto name() -> string_t { return "UInt8"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::uint8_t"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::uint16_t> {
    // the name
    inline static auto name() -> string_t { return "UInt16"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::uint16_t"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::uint32_t> {
    // the name
    inline static auto name() -> string_t { return "UInt32"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::uint32_t"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::uint64_t> {
    // the name
    inline static auto name() -> string_t { return "UInt64"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::uint64_t"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::float32_t> {
    // the name
    inline static auto name() -> string_t { return "Float"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::float_t"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::float64_t> {
    // the name
    inline static auto name() -> string_t { return "Double"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::double_t"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::complex64_t> {
    // the name
    inline static auto name() -> string_t { return "ComplexFloat"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::complex<std::float_t>"; }
};

template <>
struct pyre::memory::CellName<pyre::memory::complex128_t> {
    // the name
    inline static auto name() -> string_t { return "ComplexDouble"; }
    // c++ decl string
    inline static auto decl() -> string_t { return "std::complex<std::double_t>"; }
};


// end of file
