// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2025 all rights reserved


// code guard
#pragma once

// declarations
#include "Stack.h"


// metamethods
// constructor
template <int D, class T, bool isConst>
constexpr pyre::memory::Stack<D, T, isConst>::Stack() : _data()
{}


// interface
// get the number of cells in the block
template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::cells() const -> cell_count_type
{
    // easy
    return D;
}


// get the memory footprint of the block
template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::bytes() const -> size_type
{
    // scale the number of cells by the cell size
    return cells() * sizeof(value_type);
}


// access to the data pointer
template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::data() const -> pointer
{
    // return the raw data pointer
    return _data.data();
}


// access to the data pointer in form suitable for diagnostics
template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::where() const -> const void *
{
    // return the raw data pointer
    return _data.data();
}


// access privileges
template <int D, typename T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::readonly() -> bool
{
    // easy
    return isConst;
}


template <int D, typename T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::writable() -> bool
{
    // easy
    return !readonly();
}


// simulate my c++ declaration
template <int D, class T, bool isConst>
auto
pyre::memory::Stack<D, T, isConst>::declSelf() -> string_type
{
    // assemble and return
    return
        // namespace
        string_type("pyre::memory::") +
        // the type alias
        (isConst ? "const" : "") + "stack_t<" +
        // the template parameters
        std::to_string(D) + ", " + cell_type::declValue() +
        // and done
        ">";
}


// simulate the c++ declaration of my value
template <int D, class T, bool isConst>
auto
pyre::memory::Stack<D, T, isConst>::declValue() -> string_type
{
    // ask my cell
    return cell_type::declValue();
}


// human readable form of my type
template <int D, class T, bool isConst>
auto
pyre::memory::Stack<D, T, isConst>::className() -> string_type
{
    // resolve the name and return it
    return string_type("Stack") + std::to_string(D) + cell_type::className();
}


// iterator support
template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::begin() -> iterator
{
    // the beginning of the block
    return _data.begin();
}


template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::end() -> iterator
{
    // one past the last cell in the block
    return _data.end();
}

template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::cbegin() const -> const_iterator
{
    // the beginning of the block
    return _data.begin();
}


template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::cend() const -> const_iterator
{
    // one past the last cell in the block
    return _data.end();
}


// data access
template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::at(size_type pos) -> reference
{
    // return a reference to the cell at {pos}
    return _data.at(pos);
}


template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::at(size_type pos) const -> const_reference
{
    // return a reference to the cell at {pos}
    return _data.at(pos);
}


template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::operator[](size_type pos) -> reference
{
    // return a reference to the cell at {pos}
    return _data[pos];
}


template <int D, class T, bool isConst>
constexpr auto
pyre::memory::Stack<D, T, isConst>::operator[](size_type pos) const -> const_reference
{
    // return a reference to the cell at {pos}
    return _data[pos];
}


// end of file
