// -*- coding: utf-8 -*-
//
// bianca giovanardi
// (c) 1998-2024 all rights reserved
//


// code guard
#if !defined(pyre_tensor_algebra_icc)
#error this file contains implementation details for tensor algebra
#else


// compute 2-norm of tensor
template <pyre::tensor::tensor_c tensorT>
constexpr auto
pyre::tensor::norm(const tensorT & tensor) -> tensorT::scalar_type
    requires(tensorT::rank <= 2)
{
    using T = typename tensorT::scalar_type;

    // helper function
    constexpr auto _norm_square = []<int... J>(
                                      const tensorT & tensor, integer_sequence<J...>) -> T {
        // return sum of all square components
        return ((tensor[J] * tensor[J]) + ...);
    };

    // the size of the tensor
    constexpr int D = tensorT::size;

    // the norm square
    auto norm_square = _norm_square(tensor, make_integer_sequence<D> {});

    // correction for a symmetric tensor
    // this correction is needed because for a symmetric tensor we do not store the lower diagonal
    // components explicitly, therefore the sum of all squared components does not include the
    // lower diagonal ones
    // QUESTION: how to handle the symmetric case for a rank > 2?
    if constexpr (tensorT::symmetric && !tensorT::diagonal) {
        // extract the tensor diagonal
        auto diagonal = matrix_diagonal(tensor);

        // the length of the diagonal
        constexpr int L = decltype(diagonal)::size;

        // helper function to sum the squares of all {diagonal} components
        constexpr auto _diag_squares = []<int... J>(
                                           const auto & diagonal, integer_sequence<J...>) -> T {
            // return sum of all square components
            return ((diagonal[J] * diagonal[J]) + ...);
        };

        // double the upper diagonal norm
        norm_square *= 2;
        // remove the double contribution of the diagonal
        norm_square -= _diag_squares(diagonal, make_integer_sequence<L> {});
    }

    // take the square root
    return std::sqrt(norm_square);
}

// normalize a tensor with its 2-norm
template <pyre::tensor::tensor_c tensorT>
constexpr auto
pyre::tensor::normalize(const tensorT & tensor) -> tensorT
{
    return tensor / norm(tensor);
}

namespace {
    // tensor equality (implementation)
    template <typename T, class packingT1, class packingT2, int... I>
    constexpr auto _tensor_equal(
        const pyre::tensor::Tensor<T, packingT1, I...> & lhs,
        const pyre::tensor::Tensor<T, packingT2, I...> & rhs) -> bool
    {
        // the repacking type
        using repacking_t =
            typename pyre::tensor::repacking_sum<packingT1, packingT2>::packing_type;
        // the repacked tensor type
        using repacked_tensor_t = pyre::tensor::Tensor<T, repacking_t, I...>;
        // the number of components of the repacked tensor
        constexpr int D = repacked_tensor_t::size;
        // the type of tensor {lhs}
        using tensor1_t = pyre::tensor::Tensor<T, packingT1, I...>;
        // the type of tensor {rhs}
        using tensor2_t = pyre::tensor::Tensor<T, packingT2, I...>;

        // helper function to perform component-by-component comparison
        constexpr auto _component_wise_comparison =
            []<int... J>(
                const auto & lhs, const auto & rhs, pyre::tensor::integer_sequence<J...>) -> bool {
            // helper function to sum of component K (enumeration relative to the repacking)
            constexpr auto _component_equal = []<int K>(
                                                  const auto & lhs, const auto & rhs) -> bool {
                // get the index corresponding to the offset K in the repacking
                constexpr auto index = repacked_tensor_t::layout().index(K);
                // map the index into the offset for the packing of y1
                constexpr auto K1 = tensor1_t::layout().offset(index);
                // map the index into the offset for the packing of y2
                constexpr auto K2 = tensor2_t::layout().offset(index);
                // all done
                return lhs[K1] == rhs[K2];
            };

            // return component-wise comparison
            return (((_component_equal.template operator()<J>(lhs, rhs)) && ...));
        };

        // perform component-by-component comparison
        return _component_wise_comparison(lhs, rhs, pyre::tensor::make_integer_sequence<D> {});
    }
} // namespace

// tensors operator==
template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
constexpr auto
pyre::tensor::operator==(const tensorT1 & lhs, const tensorT2 & rhs) -> bool
{
    // perform component-by-component comparison
    return _tensor_equal(lhs, rhs);
}

namespace {
    // tensor times scalar (implementation)
    template <pyre::tensor::tensor_c tensorT, int... J>
    constexpr void _tensor_times_scalar(
        const typename tensorT::scalar_type & a, const tensorT & y, tensorT & result,
        pyre::tensor::integer_sequence<J...>)
    {
        ((result[J] = y[J] * a), ...);
        return;
    }
} // namespace

// scalar times tensor
template <pyre::tensor::tensor_c tensorT>
constexpr auto
pyre::tensor::operator*(const typename tensorT::scalar_type & a, const tensorT & y) -> tensorT
    requires(tensorT::size != 1)
{
    // instantiate the result
    tensorT result;
    constexpr int D = tensorT::size;
    _tensor_times_scalar(a, y, result, make_integer_sequence<D> {});
    return result;
}

// tensor times scalar
template <pyre::tensor::tensor_c tensorT>
constexpr auto
pyre::tensor::operator*(const tensorT & y, const typename tensorT::scalar_type & a) -> tensorT
    requires(tensorT::size != 1)
{
    return a * y;
}

// scalar times (temporary) tensor
template <pyre::tensor::tensor_c tensorT>
constexpr auto
pyre::tensor::operator*(const typename tensorT::scalar_type & a, tensorT && y) -> tensorT
    requires(tensorT::size != 1)
{
    constexpr int D = tensorT::size;
    _tensor_times_scalar(a, y, y, make_integer_sequence<D> {});
    return y;
}

// (temporary) tensor times scalar
template <pyre::tensor::tensor_c tensorT>
constexpr auto
pyre::tensor::operator*(tensorT && y, const typename tensorT::scalar_type & a) -> tensorT
    requires(tensorT::size != 1)
{
    return a * std::move(y);
}

namespace {
    // tensor plus tensor (implementation)
    template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
    constexpr auto _tensor_sum(
        const tensorT1 & y1, const tensorT2 & y2,
        typename pyre::tensor::sum<tensorT1, tensorT2>::type & result) ->
        typename pyre::tensor::sum<tensorT1, tensorT2>::type
    {
        // the resulting tensor type
        using result_tensor_t = typename pyre::tensor::sum<tensorT1, tensorT2>::type;

        // the number of components of the repacked tensor
        constexpr int D = result_tensor_t::size;

        // helper function to perform component-by-component sum
        constexpr auto _component_wise_sums = []<int... J>(
                                                  const tensorT1 & y1, const tensorT2 & y2,
                                                  result_tensor_t & result,
                                                  pyre::tensor::integer_sequence<J...>) {
            // helper function to sum of component K (enumeration relative to the repacking)
            constexpr auto _component_sum =
                []<int K>(const tensorT1 & y1, const tensorT2 & y2, result_tensor_t & result) {
                    // get the index corresponding to the offset K in the repacking
                    constexpr auto index = result_tensor_t::layout().index(K);
                    // map the index into the offset for the packing of y1
                    constexpr auto K1 = tensorT1::layout().offset(index);
                    // map the index into the offset for the packing of y2
                    constexpr auto K2 = tensorT2::layout().offset(index);

                    // perform the sum of the corresponding entries
                    result[K] = y1[K1] + y2[K2];

                    // all done
                    return;
                };

            // sum over each component J = 0, ..., size of repacking
            ((_component_sum.template operator()<J>(y1, y2, result)), ...);

            // all done
            return;
        };

        // perform component-by-component sum
        _component_wise_sums(y1, y2, result, pyre::tensor::make_integer_sequence<D> {});

        // all done
        return result;
    }

    // tensor plus tensor (implementation)
    template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
    constexpr auto _tensor_sum(const tensorT1 & y1, const tensorT2 & y2) ->
        typename pyre::tensor::sum<tensorT1, tensorT2>::type
    {
        // the resulting tensor type
        using resulting_tensor_t = typename pyre::tensor::sum<tensorT1, tensorT2>::type;

        // instantiate the result
        resulting_tensor_t result;

        return _tensor_sum(y1, y2, result);
    }
} // namespace

// tensor plus tensor
template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
constexpr auto
pyre::tensor::operator+(const tensorT1 & y1, const tensorT2 & y2) ->
    typename sum<tensorT1, tensorT2>::type
    requires(tensorT1::dims == tensorT2::dims)
{
    // compute component-wise summation
    return _tensor_sum(y1, y2);
}

// tensor plus (temporary) tensor
template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
constexpr auto
pyre::tensor::operator+(const tensorT1 & y1, tensorT2 && y2) -> tensorT2
    requires(
        tensorT1::dims == tensorT2::dims
        && std::is_same_v<typename sum<tensorT1, tensorT2>::type, tensorT2>)
{
    // compute component-wise summation and write the result on y2
    return _tensor_sum(y1, y2, y2);
}

// (temporary) tensor plus tensor
template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
constexpr auto
pyre::tensor::operator+(tensorT1 && y1, const tensorT2 & y2) -> tensorT1
    requires(
        tensorT1::dims == tensorT2::dims
        && std::is_same_v<typename sum<tensorT1, tensorT2>::type, tensorT1>)
{
    // easy enough
    return y2 + std::move(y1);
}

// (temporary) tensor plus (temporary) tensor
template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
constexpr auto
pyre::tensor::operator+(tensorT1 && y1, tensorT2 && y2) -> tensorT1
    requires(
        tensorT1::dims == tensorT2::dims
        && std::is_same_v<typename sum<tensorT1, tensorT2>::type, tensorT1>)
{
    // pass down y1 as temporary and y2 as const reference
    return std::move(y1) + std::as_const(y2);
}

// (temporary) tensor plus (temporary) tensor
template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
constexpr auto
pyre::tensor::operator+(tensorT1 && y1, tensorT2 && y2) -> tensorT2
    requires(
        tensorT1::dims == tensorT2::dims
        && std::is_same_v<typename sum<tensorT1, tensorT2>::type, tensorT2>
        && !std::is_same_v<typename sum<tensorT1, tensorT2>::type, tensorT1>)
{
    // pass down y2 as temporary and y1 as const reference
    return std::move(y2) + std::as_const(y1);
}

// (unary) minus tensor
template <pyre::tensor::tensor_c tensorT>
constexpr auto
pyre::tensor::operator-(const tensorT & y) -> tensorT
{
    // get the tensor size (number of components)
    constexpr int D = tensorT::size;

    // helper function to do component-wise operation
    constexpr auto _operator_minus =
        []<int... J>(const tensorT & tensor, integer_sequence<J...>) -> tensorT {
        // return sum of all square components
        return tensorT { -tensor[J]... };
    };

    // return the result of the component-wise operation
    return _operator_minus(y, make_integer_sequence<D> {});
}

// (unary) minus (temporary) tensor
template <pyre::tensor::tensor_c tensorT>
constexpr auto
pyre::tensor::operator-(tensorT && y) -> tensorT
{
    // write the result on the temporary
    y = -std::as_const(y);
    // all done
    return y;
}

// tensor minus tensor
template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
constexpr auto
pyre::tensor::operator-(const tensorT1 & y1, const tensorT2 & y2) -> auto
    requires(tensorT1::dims == tensorT2::dims)
{
    // std::cout << "operator- & &" << std::endl;
    return y1 + (-y2);
}

// (temporary) tensor minus tensor
template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
constexpr auto
pyre::tensor::operator-(tensorT1 && y1, const tensorT2 & y2) -> auto
    requires(tensorT1::dims == tensorT2::dims)
{
    // std::cout << "operator- && &" << std::endl;
    return std::move(y1) + (-y2);
}

// tensor minus (temporary) tensor
template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
constexpr auto
pyre::tensor::operator-(const tensorT1 & y1, tensorT2 && y2) -> auto
    requires(tensorT1::dims == tensorT2::dims)
{
    // std::cout << "operator- & &&" << std::endl;
    return y1 + (-std::move(y2));
}

// (temporary) tensor minus (temporary) tensor
template <pyre::tensor::tensor_c tensorT1, pyre::tensor::tensor_c tensorT2>
constexpr auto
pyre::tensor::operator-(tensorT1 && y1, tensorT2 && y2) -> auto
    requires(tensorT1::dims == tensorT2::dims)
{
    // std::cout << "operator- && &&" << std::endl;
    return std::move(y1) + std::move(-std::move(y2));
}

// tensor plus equal tensor
template <pyre::tensor::tensor_c tensorT, class TENSOR>
constexpr auto
pyre::tensor::operator+=(tensorT & lhs, TENSOR && rhs) -> tensorT &
{
    lhs = std::move(lhs) + std::forward<TENSOR>(rhs);
    return lhs;
}

// tensor minus equal tensor
template <pyre::tensor::tensor_c tensorT, class TENSOR>
constexpr auto
pyre::tensor::operator-=(tensorT & lhs, TENSOR && rhs) -> tensorT &
{
    lhs = std::move(lhs) - std::forward<TENSOR>(rhs);
    return lhs;
}

// tensor divided scalar
template <pyre::tensor::tensor_c tensorT>
constexpr auto
pyre::tensor::operator/(const tensorT & y, typename tensorT::scalar_type a) -> tensorT
    requires(tensorT::size != 1)
{
    return (1.0 / a) * y;
}

// (temporary) tensor divided scalar
template <pyre::tensor::tensor_c tensorT>
constexpr auto
pyre::tensor::operator/(tensorT && y, typename tensorT::scalar_type a) -> tensorT
    requires(tensorT::size != 1)
{
    return (1.0 / a) * std::move(y);
}

// builds a square matrix with all zeros except the K-th row is equal to v
template <int K, class packingT, pyre::tensor::vector_c vectorT>
constexpr auto
pyre::tensor::matrix_row(const vectorT & v)
    -> matrix_t<vectorT::size, vectorT::size, typename vectorT::scalar_type, packingT>
{
    // the type of the matrix to be returned
    using matrix_result_t =
        matrix_t<vectorT::size, vectorT::size, typename vectorT::scalar_type, packingT>;

    constexpr auto _fill_matrix_row = []<int... I>(
                                          matrix_result_t & A, const vectorT & v,
                                          integer_sequence<I...>) -> matrix_result_t {
        ((A[matrix_result_t::template getOffset<K, I>()] = v[{ I }]), ...);
        return A;
    };
    // fill row K of a zero matrix with vector v
    return _fill_matrix_row(zero<matrix_result_t>, v, make_integer_sequence<vectorT::size> {});
}

// builds a square matrix with all zeros except the K-th column is equal to v
template <int K, class packingT, pyre::tensor::vector_c vectorT>
constexpr auto
pyre::tensor::matrix_column(const vectorT & v)
    -> matrix_t<vectorT::size, vectorT::size, typename vectorT::scalar_type, packingT>
{
    // the type of the matrix to be returned
    using matrix_result_t =
        matrix_t<vectorT::size, vectorT::size, typename vectorT::scalar_type, packingT>;

    constexpr auto _fill_matrix_column = []<int... I>(
                                             matrix_result_t A, const vectorT & v,
                                             integer_sequence<I...>) -> matrix_result_t {
        ((A[matrix_result_t::template getOffset<I, K>()] = v[{ I }]), ...);
        return A;
    };
    // fill column K of a zero matrix with vector v
    return _fill_matrix_column(matrix_result_t(), v, make_integer_sequence<vectorT::size> {});
}

// builds a square matrix with all zeros except the diagonal is equal to v
template <pyre::tensor::vector_c vectorT>
constexpr auto
pyre::tensor::matrix_diagonal(const vectorT & v)
    -> diagonal_matrix_t<vectorT::size, typename vectorT::scalar_type>
{
    // the type of the matrix to be returned
    using matrix_result_t = diagonal_matrix_t<vectorT::size, typename vectorT::scalar_type>;

    constexpr auto _fill_matrix_diagonal = []<int... I>(
                                               matrix_result_t A, const vectorT & v,
                                               integer_sequence<I...>) -> matrix_result_t {
        ((A[{ I, I }] = v[{ I }]), ...);
        return A;
    };
    // instantiate a diagonal matrix
    matrix_result_t A;
    // fill diagonal of a zero matrix with vector v
    return _fill_matrix_diagonal(A, v, make_integer_sequence<vectorT::size> {});
}

// builds the vector with the diagonal entries of a matrix
template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::matrix_diagonal(const matrixT & A)
    -> vector_t<matrixT::dims[0], typename matrixT::scalar_type>
{
    // the type of the matrix to be returned
    using vector_result_t = vector_t<matrixT::dims[0], typename matrixT::scalar_type>;
    using T = typename vector_result_t::scalar_type;

    auto _fill_vector_with_matrix_diagonal =
        [&A]<int... J>(integer_sequence<J...>) -> vector_result_t {
        auto _diagonal_entry = [&A]<int K>() -> T {
            constexpr int offset = matrixT::template getOffset<K, K>();
            return A[offset];
        };
        return vector_result_t(_diagonal_entry.template operator()<J>()...);
    };
    // fill a vector with the diagonal of A and return it
    return _fill_vector_with_matrix_diagonal(make_integer_sequence<vector_result_t::size> {});
}

// row-column vector product
template <pyre::tensor::vector_c vectorT1, pyre::tensor::vector_c vectorT2>
constexpr auto
pyre::tensor::operator*(const vectorT1 & v1, const vectorT2 & v2)
    -> product<vectorT1, vectorT2>::type
    // TOFIX: rename these requires in terms of 'compatibility'
    requires(vectorT1::size == vectorT2::size)
{
    using scalar_return_type = product<vectorT1, vectorT2>::type;
    constexpr int D = vectorT1::size;

    // helper function (scalar product)
    constexpr auto _vector_times_vector = []<int... K>(
                                              const vectorT1 & v1, const vectorT2 & v2,
                                              integer_sequence<K...>) -> scalar_return_type {
        return ((v1[{ K }] * v2[{ K }]) + ...);
    };
    return _vector_times_vector(v1, v2, make_integer_sequence<D> {});
}

// matrix-vector multiplication (contract on matrix second index)
template <pyre::tensor::matrix_c matrixT, pyre::tensor::vector_c vectorT>
constexpr auto
pyre::tensor::operator*(const matrixT & A, const vectorT & v) -> product<matrixT, vectorT>::type
    requires(matrixT::dims[1] == vectorT::size)
{
    using vector_output_type = typename product<matrixT, vectorT>::type;

    // helper function
    constexpr auto _matrix_times_vector = []<int... K>(
                                              const matrixT & A, const vectorT & v,
                                              integer_sequence<K...>) -> vector_output_type {
        return vector_output_type((row<K>(A) * v)...);
    };
    return _matrix_times_vector(A, v, make_integer_sequence<matrixT::dims[0]> {});
}

// vector-matrix multiplication (contract on first matrix index)
template <pyre::tensor::matrix_c matrixT, pyre::tensor::vector_c vectorT>
constexpr auto
pyre::tensor::operator*(const vectorT & v, const matrixT & A) -> product<vectorT, matrixT>::type
    requires(matrixT::dims[0] == vectorT::size)
{
    using vector_output_type = typename product<vectorT, matrixT>::type;

    // helper function
    constexpr auto _matrix_times_vector = []<int... K>(
                                              const matrixT & A, const vectorT & v,
                                              integer_sequence<K...>) -> vector_output_type {
        return vector_output_type((col<K>(A) * v)...);
    };
    return _matrix_times_vector(A, v, make_integer_sequence<matrixT::dims[1]> {});
}

// matrix-matrix multiplication
template <pyre::tensor::matrix_c matrixT1, pyre::tensor::matrix_c matrixT2>
constexpr auto
pyre::tensor::operator*(const matrixT1 & A1, const matrixT2 & A2)
    -> product<matrixT1, matrixT2>::type
    requires(matrixT1::dims[1] == matrixT2::dims[0])
{
    // the type of the result
    using matrix_result_t = typename product<matrixT1, matrixT2>::type;
    // instantiate result
    matrix_result_t result;
    // the first dimension of {matrixT1}
    constexpr int D1 = matrixT1::dims[0];
    // the second dimension of {matrixT1} and first dimension of {matrixT2}
    constexpr int D2 = matrixT1::dims[1];
    // the second dimension of {matrixT2}
    constexpr int D3 = matrixT2::dims[1];

    // helper function to fill the {I, ...} components
    constexpr auto _fill_I = []<int... K>(
                                 const matrixT1 & A1, const matrixT2 & A2, matrix_result_t & result,
                                 integer_sequence<K...>) {
        // helper function to fill the {I, J} component
        constexpr auto _fill_J = []<int J, int... I>(
                                     const matrixT1 & A1, const matrixT2 & A2,
                                     matrix_result_t & result, integer_sequence<I...>) {
            // helper function to contract an index
            constexpr auto _contract_L = []<int II, int JJ, int... L>(
                                             const matrixT1 & A1, const matrixT2 & A2,
                                             integer_sequence<L...>) {
                // return index contraction A1[II, L] * A2[L, JJ]
                return (
                    (A1[matrixT1::template getOffset<II, L>()]
                     * A2[matrixT2::template getOffset<L, JJ>()])
                    + ...);
            };

            // compute the component {I, J} as the contraction of A1(I, K) and A2(K, J)
            ((result[matrix_result_t::template getOffset<I, J>()] =
                  _contract_L.template operator()<I, J>(A1, A2, make_integer_sequence<D2> {})),
             ...);

            // all done
            return;
        };

        // fill the {I, J} components
        (_fill_J.template operator()<K>(A1, A2, result, make_integer_sequence<D1> {}), ...);
    };

    // fill the {I, ...} components
    _fill_I(A1, A2, result, make_integer_sequence<D3> {});

    // all done
    return result;
}

// Tensor operator*=
template <pyre::tensor::tensor_c tensorT, class TENSOR>
constexpr auto
pyre::tensor::operator*=(tensorT & lhs, TENSOR && rhs) -> tensorT &
{
    lhs = std::move(lhs) * std::forward<TENSOR>(rhs);
    return lhs;
}

// Tensor operator/=
template <pyre::tensor::tensor_c tensorT, class SCALAR>
constexpr auto
pyre::tensor::operator/=(tensorT & lhs, SCALAR && rhs) -> tensorT &
{
    lhs = std::move(lhs) / std::forward<SCALAR>(rhs);
    return lhs;
}

// the skew symmetric matrix representing vector a
template <pyre::tensor::vector_c vectorT, class packingT>
constexpr auto
pyre::tensor::skew(const vectorT & a) -> square_matrix_t<3, typename vectorT::scalar_type, packingT>
    requires(vectorT::size == 3)
{
    // the type of matrix {A}
    using matrix_t = matrix_t<3, 3, typename vectorT::scalar_type, packingT>;

    // instantiate the result
    matrix_t A;

    A[matrix_t::template getOffset<0, 1>()] = -a[2];
    A[matrix_t::template getOffset<0, 2>()] = a[1];
    A[matrix_t::template getOffset<1, 0>()] = a[2];
    A[matrix_t::template getOffset<1, 2>()] = -a[0];
    A[matrix_t::template getOffset<2, 0>()] = -a[1];
    A[matrix_t::template getOffset<2, 1>()] = a[0];

    // all done
    return A;
}

template <pyre::tensor::vector_c vectorT>
constexpr auto
pyre::tensor::cross(const vectorT & a, const vectorT & b) -> auto
    requires(vectorT::size == 3)
{
    return skew(a) * b;
}

template <pyre::tensor::vector_c vectorT>
constexpr auto
pyre::tensor::cross(const vectorT & a, const vectorT & b) -> typename vectorT::scalar_type
{
    using T = typename vectorT::scalar_type;
    vector_t<3, T> a3 { a[0], a[1], 0.0 };
    vector_t<3, T> b3 { b[0], b[1], 0.0 };
    return cross(a3, b3)[2];
}

// factorial
template <int D>
constexpr auto
pyre::tensor::factorial() -> int
{
    return D * factorial<int(D - 1)>();
}

template <>
constexpr auto
pyre::tensor::factorial<1>() -> int
{
    return 1;
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::determinant(const matrixT & A) -> typename matrixT::scalar_type
    requires(matrixT::dims[0] == 4) // 4x4 matrix
{
    // the type of matrix {A}
    using matrix_t = matrixT;

    // the underlying scalar type
    using scalar_t = typename matrixT::scalar_type;

    scalar_t a11 = A[matrix_t::template getOffset<0, 0>()];
    scalar_t a12 = A[matrix_t::template getOffset<0, 1>()];
    scalar_t a13 = A[matrix_t::template getOffset<0, 2>()];
    scalar_t a14 = A[matrix_t::template getOffset<0, 3>()];
    scalar_t a21 = A[matrix_t::template getOffset<1, 0>()];
    scalar_t a22 = A[matrix_t::template getOffset<1, 1>()];
    scalar_t a23 = A[matrix_t::template getOffset<1, 2>()];
    scalar_t a24 = A[matrix_t::template getOffset<1, 3>()];
    scalar_t a31 = A[matrix_t::template getOffset<2, 0>()];
    scalar_t a32 = A[matrix_t::template getOffset<2, 1>()];
    scalar_t a33 = A[matrix_t::template getOffset<2, 2>()];
    scalar_t a34 = A[matrix_t::template getOffset<2, 3>()];
    scalar_t a41 = A[matrix_t::template getOffset<3, 0>()];
    scalar_t a42 = A[matrix_t::template getOffset<3, 1>()];
    scalar_t a43 = A[matrix_t::template getOffset<3, 2>()];
    scalar_t a44 = A[matrix_t::template getOffset<3, 3>()];

    return a12 * a34 * a43 * a21 - a12 * a33 * a44 * a21 - a34 * a42 * a13 * a21
         + a33 * a42 * a14 * a21 - a11 * a34 * a43 * a22 + a11 * a33 * a44 * a22
         + a34 * a41 * a13 * a22 - a33 * a41 * a14 * a22 - a12 * a34 * a41 * a23
         + a11 * a34 * a42 * a23 + a12 * a33 * a41 * a24 - a11 * a33 * a42 * a24
         - a44 * a13 * a22 * a31 + a43 * a14 * a22 * a31 + a12 * a44 * a23 * a31
         - a42 * a14 * a23 * a31 - a12 * a43 * a24 * a31 + a42 * a13 * a24 * a31
         + a44 * a13 * a21 * a32 - a43 * a14 * a21 * a32 - a11 * a44 * a23 * a32
         + a41 * a14 * a23 * a32 + a11 * a43 * a24 * a32 - a41 * a13 * a24 * a32;
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::determinant(const matrixT & A) -> typename matrixT::scalar_type
    requires(matrixT::dims[0] == 3) // 3x3 matrix
{
    // the type of matrix {A}
    using matrix_t = matrixT;

    // the underlying scalar type
    using scalar_t = typename matrixT::scalar_type;

    scalar_t a11 = A[matrix_t::template getOffset<0, 0>()];
    scalar_t a12 = A[matrix_t::template getOffset<0, 1>()];
    scalar_t a13 = A[matrix_t::template getOffset<0, 2>()];
    scalar_t a21 = A[matrix_t::template getOffset<1, 0>()];
    scalar_t a22 = A[matrix_t::template getOffset<1, 1>()];
    scalar_t a23 = A[matrix_t::template getOffset<1, 2>()];
    scalar_t a31 = A[matrix_t::template getOffset<2, 0>()];
    scalar_t a32 = A[matrix_t::template getOffset<2, 1>()];
    scalar_t a33 = A[matrix_t::template getOffset<2, 2>()];

    return a11 * (a22 * a33 - a23 * a32) - a12 * (a21 * a33 - a23 * a31)
         + a13 * (a21 * a32 - a22 * a31);
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::determinant(const matrixT & A) -> typename matrixT::scalar_type
    requires(matrixT::dims[0] == 2) // 2x2 matrix
{
    // the type of matrix {A}
    using matrix_t = matrixT;

    // the underlying scalar type
    using scalar_t = typename matrixT::scalar_type;

    scalar_t a11 = A[matrix_t::template getOffset<0, 0>()];
    scalar_t a22 = A[matrix_t::template getOffset<1, 1>()];
    scalar_t a12 = A[matrix_t::template getOffset<0, 1>()];
    scalar_t a21 = A[matrix_t::template getOffset<1, 0>()];

    return a11 * a22 - a12 * a21;
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::determinant(const matrixT & A) -> typename matrixT::scalar_type
    requires(matrixT::dims[0] == 1) // 1x1 matrix
{
    // the type of matrix {A}
    using matrix_t = matrixT;

    return A[matrix_t::template getOffset<0, 0>()];
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::inverse(const matrixT & A) -> matrixT
    requires(matrixT::dims[0] == 3 && !diagonal_matrix_c<matrixT>) // 3x3 matrix
{
    // the type of matrix {A}
    using matrix_t = matrixT;

    // the underlying scalar type
    using scalar_t = typename matrixT::scalar_type;

    scalar_t a11 = A[matrix_t::template getOffset<0, 0>()];
    scalar_t a12 = A[matrix_t::template getOffset<0, 1>()];
    scalar_t a13 = A[matrix_t::template getOffset<0, 2>()];
    scalar_t a21 = A[matrix_t::template getOffset<1, 0>()];
    scalar_t a22 = A[matrix_t::template getOffset<1, 1>()];
    scalar_t a23 = A[matrix_t::template getOffset<1, 2>()];
    scalar_t a31 = A[matrix_t::template getOffset<2, 0>()];
    scalar_t a32 = A[matrix_t::template getOffset<2, 1>()];
    scalar_t a33 = A[matrix_t::template getOffset<2, 2>()];

    matrix_t invA;
    scalar_t det = determinant(A);
    assert(det != 0.0);
    scalar_t detinv = 1.0 / det;
    invA[matrix_t::template getOffset<0, 0>()] = detinv * (a22 * a33 - a23 * a32);
    invA[matrix_t::template getOffset<0, 1>()] = detinv * (-a12 * a33 + a13 * a32);
    invA[matrix_t::template getOffset<0, 2>()] = detinv * (a12 * a23 - a13 * a22);
    invA[matrix_t::template getOffset<1, 0>()] = detinv * (-a21 * a33 + a23 * a31);
    invA[matrix_t::template getOffset<1, 1>()] = detinv * (a11 * a33 - a13 * a31);
    invA[matrix_t::template getOffset<1, 2>()] = detinv * (-a11 * a23 + a13 * a21);
    invA[matrix_t::template getOffset<2, 0>()] = detinv * (a21 * a32 - a22 * a31);
    invA[matrix_t::template getOffset<2, 1>()] = detinv * (-a11 * a32 + a12 * a31);
    invA[matrix_t::template getOffset<2, 2>()] = detinv * (a11 * a22 - a12 * a21);
    return invA;
}

template <typename T>
constexpr auto
pyre::tensor::inverse(const square_matrix_t<3, T, pyre::grid::diagonal_t<3>> & A)
    -> square_matrix_t<3, T, pyre::grid::diagonal_t<3>>
{
    // the type of matrix {A}
    using matrix_t = square_matrix_t<3, T, pyre::grid::diagonal_t<3>>;

    T a11 = A[matrix_t::template getOffset<0, 0>()];
    T a22 = A[matrix_t::template getOffset<1, 1>()];
    T a33 = A[matrix_t::template getOffset<2, 2>()];

    matrix_t invA;
    assert(a11 != 0.0 && a22 != 0.0 && a33 != 0.0);

    invA[matrix_t::template getOffset<0, 0>()] = 1 / a11;
    invA[matrix_t::template getOffset<1, 1>()] = 1 / a22;
    invA[matrix_t::template getOffset<2, 2>()] = 1 / a33;

    return invA;
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::inverse(const matrixT & A) -> matrixT
    requires(matrixT::dims[0] == 2 && !diagonal_matrix_c<matrixT>) // 2x2 matrix
{
    // the type of matrix {A}
    using matrix_t = matrixT;

    // the underlying scalar type
    using scalar_t = typename matrixT::scalar_type;

    scalar_t a11 = A[matrix_t::template getOffset<0, 0>()];
    scalar_t a22 = A[matrix_t::template getOffset<1, 1>()];
    scalar_t a12 = A[matrix_t::template getOffset<0, 1>()];
    scalar_t a21 = A[matrix_t::template getOffset<1, 0>()];

    matrix_t invA;
    scalar_t det = determinant(A);
    assert(det != 0.0);
    scalar_t detinv = 1.0 / det;
    invA[matrix_t::template getOffset<0, 0>()] = detinv * a22;
    invA[matrix_t::template getOffset<0, 1>()] = detinv * (-a12);
    invA[matrix_t::template getOffset<1, 0>()] = detinv * (-a21);
    invA[matrix_t::template getOffset<1, 1>()] = detinv * a11;
    return invA;
}

template <typename T>
constexpr auto
pyre::tensor::inverse(const square_matrix_t<2, T, pyre::grid::diagonal_t<2>> & A)
    -> square_matrix_t<2, T, pyre::grid::diagonal_t<2>>
{
    // the type of matrix {A}
    using matrix_t = square_matrix_t<2, T, pyre::grid::diagonal_t<2>>;

    T a11 = A[matrix_t::template getOffset<0, 0>()];
    T a22 = A[matrix_t::template getOffset<1, 1>()];

    matrix_t invA;
    assert(a11 != 0.0 && a22 != 0.0);

    invA[matrix_t::template getOffset<0, 0>()] = 1 / a11;
    invA[matrix_t::template getOffset<1, 1>()] = 1 / a22;

    return invA;
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::inverse(const matrixT & A) -> matrixT
    requires(matrixT::dims[0] == 1) // 1x1 matrix (scalar)
{
    // the type of matrix {A}
    using matrix_t = matrixT;

    return 1.0 / A[matrix_t::template getOffset<0, 0>()];
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::trace(const matrixT & A) -> typename matrixT::scalar_type
{
    constexpr int D = matrixT::dims[0];
    using T = typename matrixT::scalar_type;

    auto _trace = [&A]<int... J>(integer_sequence<J...>) -> T {
        return (A[matrixT::template getOffset<J, J>()] + ...);
    };
    return _trace(make_integer_sequence<D> {});
}

template <int D1, int D2, typename T, class packingT>
constexpr auto
pyre::tensor::transpose(const matrix_t<D1, D2, T, packingT> & A) -> matrix_t<D2, D1, T, packingT>
{
    // the type of matrix {A}
    using matrix_input_t = matrix_t<D1, D2, T, packingT>;
    using matrix_result_t = matrix_t<D2, D1, T, packingT>;

    // A transposed
    matrix_result_t AT;
    auto _transposeJ = [&A, &AT]<int... J>(integer_sequence<J...>) {
        auto _transposeI = [&A, &AT]<int K, int... I>(integer_sequence<I...>) {
            ((AT[matrix_result_t::template getOffset<K, I>()] =
                  A[matrix_input_t::template getOffset<I, K>()]),
             ...);
            return;
        };
        (_transposeI.template operator()<J>(make_integer_sequence<D1> {}), ...);
    };
    _transposeJ(make_integer_sequence<D2> {});
    return AT;
}

template <int D, typename T>
constexpr auto
pyre::tensor::transpose(const vector_t<D, T> & v) -> vector_t<D, T>
{
    // nothing to be done, transpose is trivial for vectors
    return v;
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::symmetric(const matrixT & A) -> typename matrixT::symmetric_tensor_t
{
    // the type of matrix for the result
    using matrix_result_t = typename matrixT::symmetric_tensor_t;

    constexpr int D = matrixT::dims[0];

    // the result
    matrix_result_t sym;

    // helper function to fill all rows in colum K
    auto _fill_column = [&A, &sym]<int... K>(integer_sequence<K...>) {
        // helper function to fill entry (I, J)
        auto _fill_row = [&A, &sym]<int J, int... I>(integer_sequence<I...>) {
            // symm(I, J) = 1/2 (A(I, J) + A(J, I))
            ((sym[matrix_result_t::template getOffset<I, J>()] =
                  0.5
                  * (A[matrixT::template getOffset<I, J>()]
                     + A[matrixT::template getOffset<J, I>()])),
             ...);

            // all done
            return;
        };
        // fill all rows in column K
        (_fill_row.template operator()<K>(make_integer_sequence<D> {}), ...);
    };

    // fill all columns
    _fill_column(make_integer_sequence<D> {});

    // all done
    return sym;
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::skew(const matrixT & A) -> auto
{
    constexpr int D = matrixT::dims[0];
    using packing_type = typename matrixT::pack_t;
    using scalar_type = typename matrixT::scalar_type;

    if constexpr (std::is_same_v<packing_type, pyre::grid::symmetric_t<2>>)
        return zero<symmetric_matrix_t<D, scalar_type>>;
    else
        return 0.5 * (A - transpose(A));
}

template <typename T>
constexpr auto
pyre::tensor::eigenvalues(const symmetric_matrix_t<2, T> & A) -> vector_t<2, T>
{
    // the type of matrix {A}
    using matrix_input_t = symmetric_matrix_t<2, T>;

    T a11 = A[matrix_input_t::template getOffset<0, 0>()];
    T a22 = A[matrix_input_t::template getOffset<1, 1>()];
    T a12 = A[matrix_input_t::template getOffset<0, 1>()];

    T delta = std::sqrt(4.0 * a12 * a12 + (a11 - a22) * (a11 - a22));
    return vector_t<2, T> { 0.5 * (a11 + a22 + delta), 0.5 * (a11 + a22 - delta) };
}

template <typename T>
constexpr auto
pyre::tensor::eigenvectors(const symmetric_matrix_t<2, T> & A) -> matrix_t<2, 2, T>
{
    // the type of matrix {A}
    using matrix_input_t = symmetric_matrix_t<2, T>;

    T a11 = A[matrix_input_t::template getOffset<0, 0>()];
    T a22 = A[matrix_input_t::template getOffset<1, 1>()];
    T a12 = A[matrix_input_t::template getOffset<0, 1>()];

    T delta = std::sqrt(4.0 * a12 * a12 + (a11 - a22) * (a11 - a22));

    // the type of eigenvectors matrix
    using matrix_eigenvector_t = matrix_t<2, 2, T>;

    matrix_eigenvector_t eigenvector_matrix;
    eigenvector_matrix[matrix_eigenvector_t::template getOffset<0, 0>()] = a11 - a22 + delta;
    eigenvector_matrix[matrix_eigenvector_t::template getOffset<0, 1>()] = a11 - a22 - delta;
    eigenvector_matrix[matrix_eigenvector_t::template getOffset<1, 0>()] = 2.0 * a12;
    eigenvector_matrix[matrix_eigenvector_t::template getOffset<1, 1>()] = 2.0 * a12;

    return eigenvector_matrix;
}

template <typename T>
constexpr auto
pyre::tensor::eigenvalues(const symmetric_matrix_t<3, T> & A) -> vector_t<3, T>
{
    // the type of matrix {A}
    using matrix_t = symmetric_matrix_t<3, T>;

    T a11 = A[matrix_t::template getOffset<0, 0>()];
    T a22 = A[matrix_t::template getOffset<1, 1>()];
    T a33 = A[matrix_t::template getOffset<2, 2>()];
    T a12 = A[matrix_t::template getOffset<0, 1>()];
    T a13 = A[matrix_t::template getOffset<0, 2>()];
    T a23 = A[matrix_t::template getOffset<1, 2>()];

    // Formula from Kopp 2008, "Efficient numerical diagonalization of hermitian 3 × 3 matrices"
    T c0 = a11 * a23 * a23 + a22 * a13 * a13 + a33 * a12 * a12 - a11 * a22 * a33
         - 2.0 * a13 * a12 * a23;
    T c1 = a11 * a22 + a11 * a33 + a22 * a33 - a12 * a12 - a13 * a13 - a23 * a23;
    T c2 = -a11 - a22 - a33;

    T p = c2 * c2 - 3.0 * c1;
    T q = -13.5 * c0 - c2 * c2 * c2 + 4.5 * c1 * c2;
    T num = std::sqrt(27.0 * (0.25 * c1 * c1 * (p - c1) + c0 * (q + 6.75 * c0)));
    T den = q;
    T phi = 1.0 / 3.0 * atan2(num, den);

    T x1 = 2.0 * cos(phi);
    T x2 = -cos(phi) - std::sqrt(3.0) * sin(phi);
    T x3 = -cos(phi) + std::sqrt(3.0) * sin(phi);

    T p_sqrt_3 = std::sqrt(p) / 3.0;

    return vector_t<3, T> { p_sqrt_3 * x1 - c2 / 3.0, p_sqrt_3 * x2 - c2 / 3.0,
                            p_sqrt_3 * x3 - c2 / 3.0 };
}

template <typename T>
constexpr auto
pyre::tensor::eigenvectors(const symmetric_matrix_t<3, T> & A) -> matrix_t<3, 3, T>
{
    // get the eigenvalues
    auto lambda = eigenvalues(A);
    auto eps = pyre::algebra::epsilon(norm(A));

    // first eigenvector
    vector_t<3, T> v0;
    auto a = col<0>(A) - lambda[0] * vector_t<3, T> { 1, 0, 0 };
    auto b = col<1>(A) - lambda[0] * vector_t<3, T> { 0, 1, 0 };
    if (norm(a) <= eps) {
        v0 = vector_t<3, T> { 1, 0, 0 };
    } else if (norm(b) <= eps) {
        v0 = vector_t<3, T> { 0, 1, 0 };
    } else {
        v0 = cross(a, b);
        if (norm(v0) <= eps) {
            auto mu = norm(a) / norm(b);
            v0 = vector_t<3, T> { 1, -mu, 0 };
        }
    }

    // second eigenvector
    vector_t<3, T> v1;
    // second eigenvalue is repeated
    if (lambda[1] == lambda[0]) {
        auto a = col<0>(A) - lambda[0] * vector_t<3, T> { 1, 0, 0 };
        if (norm(a) <= eps) {
            auto b = col<1>(A) - lambda[0] * vector_t<3, T> { 0, 1, 0 };
            if (norm(b) <= eps) {
                v1 = vector_t<3, T> { 0, 1, 0 };
            } else {
                v1 = cross(v0, b);
            }
        } else {
            v1 = cross(v0, a);
        }
    } else { // lambda[1] != lambda[0]
        auto a = col<0>(A) - lambda[1] * vector_t<3, T> { 1, 0, 0 };
        auto b = col<1>(A) - lambda[1] * vector_t<3, T> { 0, 1, 0 };
        if (norm(a) <= eps) {
            v1 = vector_t<3, T> { 1, 0, 0 };
        } else if (norm(b) <= eps) {
            v1 = vector_t<3, T> { 0, 1, 0 };
        } else {
            v1 = cross(a, b);
            if (norm(v1) <= eps) {
                auto mu = norm(a) / norm(b);
                v1 = vector_t<3, T> { 1, -mu, 0 };
            }
        }
    }

    // third eigenvector
    vector_t<3, T> v2 = cross(v0, v1);

    // build and return the matrix of eigenvectors
    return matrix_column<0>(v0) + matrix_column<1>(v1) + matrix_column<2>(v2);
}

template <int D, typename T>
constexpr auto
pyre::tensor::eigenvalues(const diagonal_matrix_t<D, T> & A) -> auto
{
    // the diagonal entries are the eigenvalues
    return matrix_diagonal(A);
}

template <int D, typename T>
constexpr auto
pyre::tensor::eigenvectors(const diagonal_matrix_t<D, T> & A) -> auto
{
    // the canonical basis is the set of eigenvectors
    return identity<diagonal_matrix_t<D, T>>;
}

// extract row {I} of a matrix
template <int I, pyre::tensor::matrix_c matrixT>
constexpr auto
pyre::tensor::row(const matrixT & A) -> vector_t<matrixT::dims[1], typename matrixT::scalar_type>
{
    constexpr int D1 = matrixT::dims[0];
    constexpr int D2 = matrixT::dims[1];
    using T = typename matrixT::scalar_type;

    auto _row = [&A]<int... J>(integer_sequence<J...>) -> vector_t<D2, T> {
        auto entry_IK = [&A]<int K>() -> T {
            // get the offset corresponding to multi-index (I, K) for this matrix packing
            constexpr int offset = matrixT::template getOffset<I, K>();
            return A[offset];
        };
        // return a vector filled with entries (I, J) for all J...
        return vector_t<D2, T>(entry_IK.template operator()<J>()...);
    };
    return _row(make_integer_sequence<D2> {});
}

// extract column {I} of a matrix
template <int I, pyre::tensor::matrix_c matrixT>
constexpr auto
pyre::tensor::col(const matrixT & A) -> vector_t<matrixT::dims[0], typename matrixT::scalar_type>
{
    constexpr int D1 = matrixT::dims[0];
    constexpr int D2 = matrixT::dims[1];
    using T = typename matrixT::scalar_type;

    auto _col = [&A]<int... J>(integer_sequence<J...>) -> vector_t<D1, T> {
        auto entry_KI = [&A]<int K>() -> T {
            // get the offset corresponding to multi-index (K, I) for this matrix packing
            constexpr int offset = matrixT::template getOffset<K, I>();
            return A[offset];
        };
        // return a vector filled with entries (J, I) for all J...
        return vector_t<D1, T>(entry_KI.template operator()<J>()...);
    };
    return _col(make_integer_sequence<D1> {});
}

template <pyre::tensor::square_matrix_c matrixT>
constexpr auto
pyre::tensor::function(const matrixT & A, auto f) -> auto
    requires(
        std::is_same_v<typename matrixT::pack_t, pyre::grid::symmetric_t<2>>
        || std::is_same_v<typename matrixT::pack_t, pyre::grid::diagonal_t<2>>)
{
    constexpr int D = matrixT::dims[0];

    // compute eigenvalues
    auto lambda = matrix_diagonal(eigenvalues(A));
    // compute eigenvectors
    auto P = eigenvectors(A);
    // helper function (component-wise)
    constexpr auto _apply_f_to_diagonal = []<int... I>(
                                              auto & lambda, auto f, integer_sequence<I...>) {
        // apply f to diagonal
        ((lambda[matrixT::template getOffset<I, I>()] =
              f(lambda[matrixT::template getOffset<I, I>()])),
         ...);
        // all done
        return;
    };
    // change eigenvalues into f(eigenvalues)
    _apply_f_to_diagonal(lambda, f, make_integer_sequence<D> {});
    // rebuild matrix
    return symmetric(P * lambda * inverse(P));
}


#endif

// end of file
